<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ignite Health Systems - Performance Benchmark Tests</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeInDown 0.6s ease-out;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
            transform: translateY(-2px);
        }
        
        .btn.running {
            background: #ffeb3b;
            color: #333;
        }
        
        .status {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
            font-weight: 500;
        }
        
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .benchmark-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            animation: slideInUp 0.6s ease-out;
        }
        
        .benchmark-card h3 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #ffeb3b;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }
        
        .metric-label {
            font-weight: 500;
        }
        
        .metric-value {
            font-weight: bold;
        }
        
        .metric-value.good {
            color: #4caf50;
        }
        
        .metric-value.warning {
            color: #ff9800;
        }
        
        .metric-value.poor {
            color: #f44336;
        }
        
        .benchmark-progress {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .benchmark-progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4caf50, #8bc34a);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .summary {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            animation: fadeIn 1s ease-out;
        }
        
        .overall-score {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .overall-score.excellent {
            color: #4caf50;
        }
        
        .overall-score.good {
            color: #8bc34a;
        }
        
        .overall-score.fair {
            color: #ff9800;
        }
        
        .overall-score.poor {
            color: #f44336;
        }
        
        .recommendations {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .recommendations h3 {
            margin-bottom: 15px;
            color: #ffeb3b;
        }
        
        .recommendation {
            background: rgba(0,0,0,0.2);
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #ff9800;
        }
        
        .logs {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        
        .log-entry.info {
            color: #2196f3;
        }
        
        .log-entry.success {
            color: #4caf50;
        }
        
        .log-entry.warning {
            color: #ff9800;
        }
        
        .log-entry.error {
            color: #f44336;
        }
        
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
            }
            
            .results {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸš€ Performance Benchmark Tests</h1>
            <p>Comprehensive performance validation for all optimization modules</p>
        </div>
        
        <div class="controls">
            <button class="btn" onclick="runAllBenchmarks()">Run All Benchmarks</button>
            <button class="btn" onclick="runCoreVitalsBenchmark()">Core Web Vitals</button>
            <button class="btn" onclick="runMobileBenchmark()">Mobile Performance</button>
            <button class="btn" onclick="runPWABenchmark()">PWA Performance</button>
            <button class="btn" onclick="runErrorHandlingBenchmark()">Error Handling</button>
            <button class="btn" onclick="runAssetOptimizationBenchmark()">Asset Optimization</button>
            <button class="btn" onclick="clearResults()">Clear Results</button>
        </div>
        
        <div class="status" id="status">Ready to run performance benchmarks</div>
        
        <div class="results" id="results"></div>
        
        <div class="summary" id="summary" style="display: none;"></div>
        
        <div class="recommendations" id="recommendations" style="display: none;"></div>
        
        <div class="logs" id="logs"></div>
    </div>

    <script>
        class PerformanceBenchmarkSuite {
            constructor() {
                this.results = {};
                this.isRunning = false;
                this.logs = [];
                this.benchmarks = {
                    coreVitals: {
                        name: 'Core Web Vitals',
                        weight: 0.3,
                        tests: [
                            'lcpOptimization',
                            'fidOptimization', 
                            'clsOptimization',
                            'lazyLoadingPerformance',
                            'preloadingEffectiveness'
                        ]
                    },
                    mobile: {
                        name: 'Mobile Performance',
                        weight: 0.25,
                        tests: [
                            'touchResponseTime',
                            'orientationChangePerformance',
                            'viewportOptimization',
                            'mobileRenderingSpeed',
                            'gestureRecognitionLatency'
                        ]
                    },
                    pwa: {
                        name: 'PWA Performance',
                        weight: 0.2,
                        tests: [
                            'serviceWorkerRegistration',
                            'cacheEfficiency',
                            'offlinePerformance',
                            'manifestLoading',
                            'installPromptSpeed'
                        ]
                    },
                    errorHandling: {
                        name: 'Error Handling Performance',
                        weight: 0.15,
                        tests: [
                            'errorDetectionSpeed',
                            'recoveryMechanismLatency',
                            'fallbackLoadingTime',
                            'errorReportingOverhead',
                            'gracefulDegradationSpeed'
                        ]
                    },
                    assetOptimization: {
                        name: 'Asset Optimization',
                        weight: 0.1,
                        tests: [
                            'imageLoadingOptimization',
                            'cssLoadingPerformance',
                            'jsExecutionOptimization',
                            'fontLoadingStrategy',
                            'resourceHintEffectiveness'
                        ]
                    }
                };
                this.thresholds = {
                    excellent: 90,
                    good: 80,
                    fair: 70,
                    poor: 0
                };
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                this.logs.push({ message: logEntry, type });
                this.updateLogsDisplay();
                console.log(`%c${logEntry}`, `color: ${this.getLogColor(type)}`);
            }

            getLogColor(type) {
                const colors = {
                    info: '#2196f3',
                    success: '#4caf50',
                    warning: '#ff9800',
                    error: '#f44336'
                };
                return colors[type] || '#ffffff';
            }

            updateLogsDisplay() {
                const logsContainer = document.getElementById('logs');
                logsContainer.innerHTML = this.logs.slice(-50).map(log => 
                    `<div class="log-entry ${log.type}">${log.message}</div>`
                ).join('');
                logsContainer.scrollTop = logsContainer.scrollHeight;
            }

            updateStatus(message) {
                document.getElementById('status').textContent = message;
            }

            async runAllBenchmarks() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.results = {};
                this.logs = [];
                
                this.updateStatus('Running comprehensive performance benchmarks...');
                this.log('Starting comprehensive performance benchmark suite', 'info');
                
                for (const [key, benchmark] of Object.entries(this.benchmarks)) {
                    await this.runBenchmarkCategory(key, benchmark);
                }
                
                this.calculateOverallScore();
                this.displayResults();
                this.generateRecommendations();
                
                this.updateStatus('All benchmarks completed');
                this.log('Comprehensive performance benchmarks completed', 'success');
                this.isRunning = false;
            }

            async runBenchmarkCategory(categoryKey, category) {
                this.log(`Starting ${category.name} benchmarks`, 'info');
                
                const categoryResults = {
                    name: category.name,
                    weight: category.weight,
                    tests: {},
                    score: 0,
                    status: 'UNKNOWN'
                };

                for (const testName of category.tests) {
                    try {
                        const testResult = await this.runBenchmarkTest(categoryKey, testName);
                        categoryResults.tests[testName] = testResult;
                        await this.wait(100); // Small delay between tests
                    } catch (error) {
                        this.log(`Error in ${testName}: ${error.message}`, 'error');
                        categoryResults.tests[testName] = {
                            score: 0,
                            time: 0,
                            details: `Error: ${error.message}`,
                            status: 'ERROR'
                        };
                    }
                }

                // Calculate category score
                const testScores = Object.values(categoryResults.tests).map(t => t.score);
                categoryResults.score = testScores.reduce((sum, score) => sum + score, 0) / testScores.length;
                categoryResults.status = this.getScoreStatus(categoryResults.score);

                this.results[categoryKey] = categoryResults;
                this.updateProgress(categoryKey, categoryResults);
                
                this.log(`${category.name} completed with score: ${categoryResults.score.toFixed(1)}`, 
                    categoryResults.score >= 80 ? 'success' : 'warning');
            }

            async runBenchmarkTest(category, testName) {
                const startTime = performance.now();
                let result = { score: 0, details: 'Test not implemented', status: 'SKIPPED' };

                try {
                    switch (category) {
                        case 'coreVitals':
                            result = await this.runCoreVitalsTest(testName);
                            break;
                        case 'mobile':
                            result = await this.runMobileTest(testName);
                            break;
                        case 'pwa':
                            result = await this.runPWATest(testName);
                            break;
                        case 'errorHandling':
                            result = await this.runErrorHandlingTest(testName);
                            break;
                        case 'assetOptimization':
                            result = await this.runAssetOptimizationTest(testName);
                            break;
                    }
                } catch (error) {
                    result = {
                        score: 0,
                        details: `Test failed: ${error.message}`,
                        status: 'ERROR'
                    };
                }

                const endTime = performance.now();
                result.time = endTime - startTime;
                result.status = result.status || this.getScoreStatus(result.score);

                return result;
            }

            async runCoreVitalsTest(testName) {
                switch (testName) {
                    case 'lcpOptimization':
                        return await this.benchmarkLCPOptimization();
                    case 'fidOptimization':
                        return await this.benchmarkFIDOptimization();
                    case 'clsOptimization':
                        return await this.benchmarkCLSOptimization();
                    case 'lazyLoadingPerformance':
                        return await this.benchmarkLazyLoadingPerformance();
                    case 'preloadingEffectiveness':
                        return await this.benchmarkPreloadingEffectiveness();
                    default:
                        return { score: 0, details: 'Unknown test', status: 'SKIPPED' };
                }
            }

            async benchmarkLCPOptimization() {
                let score = 0;
                let details = 'LCP optimization analysis: ';
                
                // Check for preload links
                const preloadLinks = document.querySelectorAll('link[rel="preload"]');
                if (preloadLinks.length > 0) {
                    score += 30;
                    details += `Found ${preloadLinks.length} preload resources. `;
                }
                
                // Check for critical CSS
                const inlineStyles = document.querySelectorAll('style');
                if (inlineStyles.length > 0) {
                    score += 25;
                    details += `Critical CSS inlined. `;
                }
                
                // Check for Core Vitals optimizer
                if (window.IgniteCoreVitals) {
                    score += 45;
                    details += 'Core Vitals optimizer active. ';
                    
                    const metrics = window.IgniteCoreVitals.getMetrics();
                    if (metrics && metrics.lcp) {
                        if (metrics.lcp <= 2500) score += 20;
                        else if (metrics.lcp <= 4000) score += 10;
                        details += `Current LCP: ${metrics.lcp}ms. `;
                    }
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkFIDOptimization() {
                let score = 0;
                let details = 'FID optimization analysis: ';
                
                // Test input responsiveness
                const startTime = performance.now();
                const testInput = document.createElement('input');
                testInput.style.position = 'absolute';
                testInput.style.left = '-9999px';
                document.body.appendChild(testInput);
                
                testInput.focus();
                testInput.value = 'test';
                
                const responseTime = performance.now() - startTime;
                document.body.removeChild(testInput);
                
                if (responseTime < 50) {
                    score += 50;
                    details += `Input response time: ${responseTime.toFixed(2)}ms (Excellent). `;
                } else if (responseTime < 100) {
                    score += 35;
                    details += `Input response time: ${responseTime.toFixed(2)}ms (Good). `;
                } else {
                    score += 20;
                    details += `Input response time: ${responseTime.toFixed(2)}ms (Needs improvement). `;
                }
                
                // Check for deferred scripts
                const deferredScripts = document.querySelectorAll('script[defer]');
                if (deferredScripts.length > 0) {
                    score += 30;
                    details += `${deferredScripts.length} scripts deferred. `;
                }
                
                // Check Core Vitals optimizer FID handling
                if (window.IgniteCoreVitals) {
                    score += 20;
                    details += 'FID optimization active. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkCLSOptimization() {
                let score = 0;
                let details = 'CLS optimization analysis: ';
                
                // Check for images with dimensions
                const imagesWithDimensions = document.querySelectorAll('img[width][height]');
                const totalImages = document.querySelectorAll('img').length;
                
                if (totalImages > 0) {
                    const dimensionRatio = imagesWithDimensions.length / totalImages;
                    score += dimensionRatio * 40;
                    details += `${Math.round(dimensionRatio * 100)}% of images have dimensions. `;
                }
                
                // Check for layout-stable elements
                const elementsWithFixedSizes = document.querySelectorAll('[style*="width"][style*="height"]');
                if (elementsWithFixedSizes.length > 0) {
                    score += 20;
                    details += `${elementsWithFixedSizes.length} elements with fixed dimensions. `;
                }
                
                // Check Core Vitals optimizer CLS handling
                if (window.IgniteCoreVitals) {
                    score += 40;
                    details += 'CLS optimization active. ';
                    
                    const metrics = window.IgniteCoreVitals.getMetrics();
                    if (metrics && metrics.cls !== undefined) {
                        if (metrics.cls <= 0.1) score += 20;
                        else if (metrics.cls <= 0.25) score += 10;
                        details += `Current CLS: ${metrics.cls.toFixed(3)}. `;
                    }
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkLazyLoadingPerformance() {
                let score = 0;
                let details = 'Lazy loading performance analysis: ';
                
                // Check for IntersectionObserver support
                if ('IntersectionObserver' in window) {
                    score += 30;
                    details += 'IntersectionObserver supported. ';
                }
                
                // Check for lazy loading images
                const lazyImages = document.querySelectorAll('img[loading="lazy"]');
                if (lazyImages.length > 0) {
                    score += 40;
                    details += `${lazyImages.length} images with lazy loading. `;
                }
                
                // Test lazy loading performance
                const testImage = document.createElement('img');
                testImage.loading = 'lazy';
                testImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzMzMyIvPjwvc3ZnPg==';
                testImage.style.position = 'absolute';
                testImage.style.left = '-9999px';
                
                const loadStart = performance.now();
                document.body.appendChild(testImage);
                
                return new Promise((resolve) => {
                    testImage.onload = () => {
                        const loadTime = performance.now() - loadStart;
                        document.body.removeChild(testImage);
                        
                        if (loadTime < 50) {
                            score += 30;
                            details += `Lazy load time: ${loadTime.toFixed(2)}ms (Fast). `;
                        } else if (loadTime < 100) {
                            score += 20;
                            details += `Lazy load time: ${loadTime.toFixed(2)}ms (Good). `;
                        } else {
                            score += 10;
                            details += `Lazy load time: ${loadTime.toFixed(2)}ms (Slow). `;
                        }
                        
                        resolve({
                            score: Math.min(score, 100),
                            details,
                            status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                        });
                    };
                    
                    testImage.onerror = () => {
                        document.body.removeChild(testImage);
                        resolve({
                            score: Math.min(score, 100),
                            details: details + 'Image load test failed. ',
                            status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                        });
                    };
                });
            }

            async benchmarkPreloadingEffectiveness() {
                let score = 0;
                let details = 'Resource preloading effectiveness: ';
                
                const preloadLinks = document.querySelectorAll('link[rel="preload"]');
                score += Math.min(preloadLinks.length * 15, 60);
                details += `${preloadLinks.length} preload resources. `;
                
                // Check preload types
                const imagePreloads = document.querySelectorAll('link[rel="preload"][as="image"]');
                const stylePreloads = document.querySelectorAll('link[rel="preload"][as="style"]');
                const scriptPreloads = document.querySelectorAll('link[rel="preload"][as="script"]');
                
                if (imagePreloads.length > 0) {
                    score += 15;
                    details += `${imagePreloads.length} image preloads. `;
                }
                if (stylePreloads.length > 0) {
                    score += 15;
                    details += `${stylePreloads.length} style preloads. `;
                }
                if (scriptPreloads.length > 0) {
                    score += 10;
                    details += `${scriptPreloads.length} script preloads. `;
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async runMobileTest(testName) {
                switch (testName) {
                    case 'touchResponseTime':
                        return await this.benchmarkTouchResponseTime();
                    case 'orientationChangePerformance':
                        return await this.benchmarkOrientationChangePerformance();
                    case 'viewportOptimization':
                        return await this.benchmarkViewportOptimization();
                    case 'mobileRenderingSpeed':
                        return await this.benchmarkMobileRenderingSpeed();
                    case 'gestureRecognitionLatency':
                        return await this.benchmarkGestureRecognitionLatency();
                    default:
                        return { score: 0, details: 'Unknown test', status: 'SKIPPED' };
                }
            }

            async benchmarkTouchResponseTime() {
                let score = 0;
                let details = 'Touch response time analysis: ';
                
                // Check for touch support
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                    score += 30;
                    details += 'Touch events supported. ';
                }
                
                // Test touch event handling speed
                const testElement = document.createElement('div');
                testElement.style.position = 'absolute';
                testElement.style.left = '-9999px';
                testElement.style.width = '100px';
                testElement.style.height = '100px';
                document.body.appendChild(testElement);
                
                let touchStartTime, touchResponseTime;
                
                return new Promise((resolve) => {
                    const touchHandler = () => {
                        touchResponseTime = performance.now() - touchStartTime;
                        document.body.removeChild(testElement);
                        
                        if (touchResponseTime < 50) {
                            score += 40;
                            details += `Touch response: ${touchResponseTime.toFixed(2)}ms (Excellent). `;
                        } else if (touchResponseTime < 100) {
                            score += 30;
                            details += `Touch response: ${touchResponseTime.toFixed(2)}ms (Good). `;
                        } else {
                            score += 15;
                            details += `Touch response: ${touchResponseTime.toFixed(2)}ms (Slow). `;
                        }
                        
                        // Check mobile optimizer
                        if (window.IgniteMobile) {
                            score += 30;
                            details += 'Mobile optimizer active. ';
                        }
                        
                        resolve({
                            score: Math.min(score, 100),
                            details,
                            status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                        });
                    };
                    
                    testElement.addEventListener('click', touchHandler);
                    
                    // Simulate touch/click
                    setTimeout(() => {
                        touchStartTime = performance.now();
                        testElement.click();
                    }, 100);
                });
            }

            async benchmarkOrientationChangePerformance() {
                let score = 0;
                let details = 'Orientation change performance: ';
                
                // Check viewport meta tag
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    score += 40;
                    details += 'Viewport meta configured. ';
                }
                
                // Check for orientation handling
                if ('orientation' in window || 'onorientationchange' in window) {
                    score += 30;
                    details += 'Orientation events supported. ';
                }
                
                // Check mobile optimizer orientation handling
                if (window.IgniteMobile && window.IgniteMobile.device) {
                    score += 30;
                    details += `Current orientation: ${window.IgniteMobile.device.orientation}. `;
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkViewportOptimization() {
                let score = 0;
                let details = 'Viewport optimization analysis: ';
                
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    score += 50;
                    const content = viewportMeta.getAttribute('content');
                    details += `Viewport: ${content}. `;
                    
                    if (content.includes('width=device-width')) {
                        score += 25;
                        details += 'Device width responsive. ';
                    }
                    if (content.includes('initial-scale=1')) {
                        score += 25;
                        details += 'Initial scale optimized. ';
                    }
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkMobileRenderingSpeed() {
                let score = 0;
                let details = 'Mobile rendering speed: ';
                
                const startTime = performance.now();
                
                // Create test elements
                const testContainer = document.createElement('div');
                testContainer.style.position = 'absolute';
                testContainer.style.left = '-9999px';
                testContainer.innerHTML = `
                    <div style="display: flex; flex-direction: column;">
                        <div style="background: linear-gradient(45deg, red, blue); width: 100px; height: 100px;"></div>
                        <div style="transform: translateX(50px) rotate(45deg); width: 50px; height: 50px; background: green;"></div>
                    </div>
                `;
                
                document.body.appendChild(testContainer);
                
                // Force layout
                testContainer.offsetHeight;
                
                const renderTime = performance.now() - startTime;
                document.body.removeChild(testContainer);
                
                if (renderTime < 10) {
                    score += 50;
                    details += `Render time: ${renderTime.toFixed(2)}ms (Fast). `;
                } else if (renderTime < 20) {
                    score += 35;
                    details += `Render time: ${renderTime.toFixed(2)}ms (Good). `;
                } else {
                    score += 20;
                    details += `Render time: ${renderTime.toFixed(2)}ms (Slow). `;
                }
                
                // Check for hardware acceleration hints
                const acceleratedElements = document.querySelectorAll('[style*="transform"], [style*="opacity"]');
                if (acceleratedElements.length > 0) {
                    score += 30;
                    details += `${acceleratedElements.length} potentially accelerated elements. `;
                }
                
                // Check mobile optimizer
                if (window.IgniteMobile) {
                    score += 20;
                    details += 'Mobile rendering optimizations active. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkGestureRecognitionLatency() {
                let score = 0;
                let details = 'Gesture recognition latency: ';
                
                // Check for gesture support
                if ('PointerEvent' in window) {
                    score += 30;
                    details += 'Pointer events supported. ';
                }
                
                if ('TouchEvent' in window) {
                    score += 30;
                    details += 'Touch events supported. ';
                }
                
                // Check mobile optimizer gesture handling
                if (window.IgniteMobile && window.IgniteMobile.gestures) {
                    score += 40;
                    details += 'Advanced gesture recognition active. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async runPWATest(testName) {
                switch (testName) {
                    case 'serviceWorkerRegistration':
                        return await this.benchmarkServiceWorkerRegistration();
                    case 'cacheEfficiency':
                        return await this.benchmarkCacheEfficiency();
                    case 'offlinePerformance':
                        return await this.benchmarkOfflinePerformance();
                    case 'manifestLoading':
                        return await this.benchmarkManifestLoading();
                    case 'installPromptSpeed':
                        return await this.benchmarkInstallPromptSpeed();
                    default:
                        return { score: 0, details: 'Unknown test', status: 'SKIPPED' };
                }
            }

            async benchmarkServiceWorkerRegistration() {
                let score = 0;
                let details = 'Service Worker registration: ';
                
                if ('serviceWorker' in navigator) {
                    score += 50;
                    details += 'Service Worker supported. ';
                    
                    try {
                        const registration = await navigator.serviceWorker.getRegistration();
                        if (registration) {
                            score += 50;
                            details += `Service Worker registered (${registration.scope}). `;
                        } else {
                            details += 'No Service Worker registered. ';
                        }
                    } catch (error) {
                        details += `Service Worker check failed: ${error.message}. `;
                    }
                } else {
                    details += 'Service Worker not supported. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkCacheEfficiency() {
                let score = 0;
                let details = 'Cache efficiency: ';
                
                if ('caches' in window) {
                    score += 40;
                    details += 'Cache API supported. ';
                    
                    try {
                        const cacheNames = await caches.keys();
                        if (cacheNames.length > 0) {
                            score += 40;
                            details += `${cacheNames.length} cache(s) active. `;
                        }
                        
                        // Test cache performance
                        const testCache = await caches.open('benchmark-test');
                        const startTime = performance.now();
                        await testCache.put('/benchmark-test', new Response('test'));
                        await testCache.match('/benchmark-test');
                        const cacheTime = performance.now() - startTime;
                        await caches.delete('benchmark-test');
                        
                        if (cacheTime < 10) {
                            score += 20;
                            details += `Cache ops: ${cacheTime.toFixed(2)}ms (Fast). `;
                        } else {
                            score += 10;
                            details += `Cache ops: ${cacheTime.toFixed(2)}ms (Slow). `;
                        }
                    } catch (error) {
                        details += `Cache test failed: ${error.message}. `;
                    }
                } else {
                    details += 'Cache API not supported. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkOfflinePerformance() {
                let score = 0;
                let details = 'Offline performance: ';
                
                // Check navigator.onLine
                if ('onLine' in navigator) {
                    score += 20;
                    details += `Online status: ${navigator.onLine}. `;
                }
                
                // Check for PWA installer
                if (window.IgnitePWA) {
                    score += 40;
                    details += 'PWA features active. ';
                    
                    if (window.IgnitePWA.pwaState) {
                        score += 20;
                        details += `PWA state managed. `;
                    }
                }
                
                // Check service worker for offline capability
                if ('serviceWorker' in navigator) {
                    score += 20;
                    details += 'Offline capability possible. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkManifestLoading() {
                let score = 0;
                let details = 'Manifest loading: ';
                
                const manifestLink = document.querySelector('link[rel="manifest"]');
                if (manifestLink) {
                    score += 50;
                    details += `Manifest linked: ${manifestLink.href}. `;
                    
                    try {
                        const startTime = performance.now();
                        const response = await fetch(manifestLink.href);
                        const loadTime = performance.now() - startTime;
                        
                        if (response.ok) {
                            score += 30;
                            details += `Manifest loaded in ${loadTime.toFixed(2)}ms. `;
                            
                            const manifest = await response.json();
                            if (manifest.name && manifest.short_name) {
                                score += 20;
                                details += 'Manifest valid. ';
                            }
                        }
                    } catch (error) {
                        details += `Manifest load failed: ${error.message}. `;
                    }
                } else {
                    details += 'No manifest found. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkInstallPromptSpeed() {
                let score = 0;
                let details = 'Install prompt speed: ';
                
                if (window.IgnitePWA) {
                    score += 50;
                    details += 'PWA installer active. ';
                    
                    if (window.IgnitePWA.pwaState && window.IgnitePWA.pwaState.isInstallable) {
                        score += 50;
                        details += 'App installable. ';
                    } else {
                        score += 25;
                        details += 'Install state tracked. ';
                    }
                } else {
                    details += 'No PWA installer found. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async runErrorHandlingTest(testName) {
                switch (testName) {
                    case 'errorDetectionSpeed':
                        return await this.benchmarkErrorDetectionSpeed();
                    case 'recoveryMechanismLatency':
                        return await this.benchmarkRecoveryMechanismLatency();
                    case 'fallbackLoadingTime':
                        return await this.benchmarkFallbackLoadingTime();
                    case 'errorReportingOverhead':
                        return await this.benchmarkErrorReportingOverhead();
                    case 'gracefulDegradationSpeed':
                        return await this.benchmarkGracefulDegradationSpeed();
                    default:
                        return { score: 0, details: 'Unknown test', status: 'SKIPPED' };
                }
            }

            async benchmarkErrorDetectionSpeed() {
                let score = 0;
                let details = 'Error detection speed: ';
                
                if (window.IgniteErrorHandler) {
                    score += 40;
                    details += 'Error handler active. ';
                    
                    const startTime = performance.now();
                    
                    // Simulate error detection
                    const testError = new Error('Benchmark test error');
                    if (window.IgniteErrorHandler.reportError) {
                        window.IgniteErrorHandler.reportError('benchmark-test', testError, {
                            source: 'performance-benchmark'
                        });
                        
                        const detectionTime = performance.now() - startTime;
                        
                        if (detectionTime < 5) {
                            score += 40;
                            details += `Detection time: ${detectionTime.toFixed(2)}ms (Fast). `;
                        } else if (detectionTime < 10) {
                            score += 30;
                            details += `Detection time: ${detectionTime.toFixed(2)}ms (Good). `;
                        } else {
                            score += 20;
                            details += `Detection time: ${detectionTime.toFixed(2)}ms (Slow). `;
                        }
                    }
                    
                    // Check error statistics
                    if (window.IgniteErrorHandler.getErrorStats) {
                        score += 20;
                        details += 'Error statistics tracked. ';
                    }
                } else {
                    details += 'No error handler found. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkRecoveryMechanismLatency() {
                let score = 0;
                let details = 'Recovery mechanism latency: ';
                
                // Test image error recovery
                const testImg = document.createElement('img');
                testImg.src = 'nonexistent-benchmark-' + Date.now() + '.jpg';
                testImg.style.position = 'absolute';
                testImg.style.left = '-9999px';
                
                return new Promise((resolve) => {
                    const startTime = performance.now();
                    let recoveryAttempted = false;
                    
                    testImg.onerror = function() {
                        if (!recoveryAttempted) {
                            recoveryAttempted = true;
                            const recoveryTime = performance.now() - startTime;
                            
                            if (recoveryTime < 50) {
                                score += 50;
                                details += `Recovery time: ${recoveryTime.toFixed(2)}ms (Fast). `;
                            } else if (recoveryTime < 100) {
                                score += 35;
                                details += `Recovery time: ${recoveryTime.toFixed(2)}ms (Good). `;
                            } else {
                                score += 20;
                                details += `Recovery time: ${recoveryTime.toFixed(2)}ms (Slow). `;
                            }
                            
                            document.body.removeChild(testImg);
                            
                            if (window.IgniteErrorHandler) {
                                score += 50;
                                details += 'Error handler provides recovery. ';
                            }
                            
                            resolve({
                                score: Math.min(score, 100),
                                details,
                                status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                            });
                        }
                    };
                    
                    document.body.appendChild(testImg);
                    
                    // Timeout fallback
                    setTimeout(() => {
                        if (!recoveryAttempted) {
                            document.body.removeChild(testImg);
                            resolve({
                                score: 0,
                                details: 'No recovery mechanism detected. ',
                                status: 'POOR'
                            });
                        }
                    }, 1000);
                });
            }

            async benchmarkFallbackLoadingTime() {
                let score = 0;
                let details = 'Fallback loading time: ';
                
                // Test CSS fallback
                const testElement = document.createElement('div');
                testElement.style.fontFamily = 'NonExistentFont, Arial, sans-serif';
                testElement.textContent = 'Fallback test';
                testElement.style.position = 'absolute';
                testElement.style.left = '-9999px';
                
                const startTime = performance.now();
                document.body.appendChild(testElement);
                
                // Force layout
                testElement.offsetHeight;
                
                const fallbackTime = performance.now() - startTime;
                document.body.removeChild(testElement);
                
                if (fallbackTime < 10) {
                    score += 50;
                    details += `CSS fallback: ${fallbackTime.toFixed(2)}ms (Fast). `;
                } else if (fallbackTime < 20) {
                    score += 35;
                    details += `CSS fallback: ${fallbackTime.toFixed(2)}ms (Good). `;
                } else {
                    score += 20;
                    details += `CSS fallback: ${fallbackTime.toFixed(2)}ms (Slow). `;
                }
                
                // Check for fallback strategies
                const fallbackElements = document.querySelectorAll('[style*="fallback"], .fallback');
                if (fallbackElements.length > 0) {
                    score += 30;
                    details += `${fallbackElements.length} fallback elements found. `;
                }
                
                if (window.IgniteErrorHandler) {
                    score += 20;
                    details += 'Error handler manages fallbacks. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkErrorReportingOverhead() {
                let score = 0;
                let details = 'Error reporting overhead: ';
                
                if (window.IgniteErrorHandler && window.IgniteErrorHandler.reportError) {
                    const iterations = 10;
                    const startTime = performance.now();
                    
                    for (let i = 0; i < iterations; i++) {
                        window.IgniteErrorHandler.reportError(
                            `benchmark-overhead-${i}`,
                            new Error('Overhead test'),
                            { iteration: i }
                        );
                    }
                    
                    const totalTime = performance.now() - startTime;
                    const averageTime = totalTime / iterations;
                    
                    if (averageTime < 1) {
                        score += 60;
                        details += `Avg overhead: ${averageTime.toFixed(3)}ms (Minimal). `;
                    } else if (averageTime < 5) {
                        score += 40;
                        details += `Avg overhead: ${averageTime.toFixed(3)}ms (Low). `;
                    } else {
                        score += 20;
                        details += `Avg overhead: ${averageTime.toFixed(3)}ms (High). `;
                    }
                    
                    // Check if error handler has async reporting
                    score += 40;
                    details += 'Error reporting system active. ';
                } else {
                    details += 'No error reporting system found. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkGracefulDegradationSpeed() {
                let score = 0;
                let details = 'Graceful degradation speed: ';
                
                // Test feature detection speed
                const startTime = performance.now();
                
                const features = [
                    'IntersectionObserver' in window,
                    'serviceWorker' in navigator,
                    'requestIdleCallback' in window,
                    'PerformanceObserver' in window,
                    'ResizeObserver' in window
                ];
                
                const detectionTime = performance.now() - startTime;
                
                if (detectionTime < 1) {
                    score += 40;
                    details += `Feature detection: ${detectionTime.toFixed(3)}ms (Fast). `;
                } else {
                    score += 20;
                    details += `Feature detection: ${detectionTime.toFixed(3)}ms (Slow). `;
                }
                
                const supportedFeatures = features.filter(Boolean).length;
                score += supportedFeatures * 8;
                details += `${supportedFeatures}/5 features supported. `;
                
                // Check for polyfills
                const scripts = Array.from(document.querySelectorAll('script'));
                const hasPolyfills = scripts.some(script => 
                    script.src.includes('polyfill') || 
                    script.textContent.includes('polyfill')
                );
                
                if (hasPolyfills) {
                    score += 20;
                    details += 'Polyfills detected. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async runAssetOptimizationTest(testName) {
                switch (testName) {
                    case 'imageLoadingOptimization':
                        return await this.benchmarkImageLoadingOptimization();
                    case 'cssLoadingPerformance':
                        return await this.benchmarkCSSLoadingPerformance();
                    case 'jsExecutionOptimization':
                        return await this.benchmarkJSExecutionOptimization();
                    case 'fontLoadingStrategy':
                        return await this.benchmarkFontLoadingStrategy();
                    case 'resourceHintEffectiveness':
                        return await this.benchmarkResourceHintEffectiveness();
                    default:
                        return { score: 0, details: 'Unknown test', status: 'SKIPPED' };
                }
            }

            async benchmarkImageLoadingOptimization() {
                let score = 0;
                let details = 'Image loading optimization: ';
                
                const images = document.querySelectorAll('img');
                const lazyImages = document.querySelectorAll('img[loading="lazy"]');
                const responsiveImages = document.querySelectorAll('img[sizes]');
                const preloadedImages = document.querySelectorAll('link[rel="preload"][as="image"]');
                
                if (images.length > 0) {
                    const lazyRatio = lazyImages.length / images.length;
                    score += lazyRatio * 30;
                    details += `${Math.round(lazyRatio * 100)}% lazy loading. `;
                    
                    const responsiveRatio = responsiveImages.length / images.length;
                    score += responsiveRatio * 25;
                    details += `${Math.round(responsiveRatio * 100)}% responsive. `;
                }
                
                if (preloadedImages.length > 0) {
                    score += Math.min(preloadedImages.length * 15, 45);
                    details += `${preloadedImages.length} preloaded images. `;
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkCSSLoadingPerformance() {
                let score = 0;
                let details = 'CSS loading performance: ';
                
                const stylesheets = document.querySelectorAll('link[rel="stylesheet"]');
                const inlineStyles = document.querySelectorAll('style');
                const preloadedStyles = document.querySelectorAll('link[rel="preload"][as="style"]');
                
                if (inlineStyles.length > 0) {
                    score += 40;
                    details += `${inlineStyles.length} inline styles (critical CSS). `;
                }
                
                if (preloadedStyles.length > 0) {
                    score += 30;
                    details += `${preloadedStyles.length} preloaded stylesheets. `;
                }
                
                if (stylesheets.length > 0) {
                    score += 30;
                    details += `${stylesheets.length} external stylesheets. `;
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkJSExecutionOptimization() {
                let score = 0;
                let details = 'JavaScript execution optimization: ';
                
                const scripts = document.querySelectorAll('script');
                const deferredScripts = document.querySelectorAll('script[defer]');
                const asyncScripts = document.querySelectorAll('script[async]');
                const moduleScripts = document.querySelectorAll('script[type="module"]');
                
                if (scripts.length > 0) {
                    const deferredRatio = deferredScripts.length / scripts.length;
                    score += deferredRatio * 40;
                    details += `${Math.round(deferredRatio * 100)}% deferred scripts. `;
                    
                    const asyncRatio = asyncScripts.length / scripts.length;
                    score += asyncRatio * 30;
                    details += `${Math.round(asyncRatio * 100)}% async scripts. `;
                }
                
                if (moduleScripts.length > 0) {
                    score += 30;
                    details += `${moduleScripts.length} ES6 modules. `;
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkFontLoadingStrategy() {
                let score = 0;
                let details = 'Font loading strategy: ';
                
                const preconnectLinks = document.querySelectorAll('link[rel="preconnect"]');
                const fontPreloads = document.querySelectorAll('link[rel="preload"][as="font"]');
                const fontDisplayStyles = Array.from(document.styleSheets).some(sheet => {
                    try {
                        return Array.from(sheet.cssRules).some(rule => 
                            rule.style && rule.style.fontDisplay
                        );
                    } catch (e) {
                        return false;
                    }
                });
                
                if (preconnectLinks.length > 0) {
                    score += 40;
                    details += `${preconnectLinks.length} preconnect links. `;
                }
                
                if (fontPreloads.length > 0) {
                    score += 40;
                    details += `${fontPreloads.length} font preloads. `;
                }
                
                if (fontDisplayStyles) {
                    score += 20;
                    details += 'Font-display optimization. ';
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            async benchmarkResourceHintEffectiveness() {
                let score = 0;
                let details = 'Resource hint effectiveness: ';
                
                const dnsPrefetch = document.querySelectorAll('link[rel="dns-prefetch"]');
                const preconnect = document.querySelectorAll('link[rel="preconnect"]');
                const preload = document.querySelectorAll('link[rel="preload"]');
                const prefetch = document.querySelectorAll('link[rel="prefetch"]');
                
                if (dnsPrefetch.length > 0) {
                    score += 20;
                    details += `${dnsPrefetch.length} DNS prefetch. `;
                }
                
                if (preconnect.length > 0) {
                    score += 30;
                    details += `${preconnect.length} preconnect. `;
                }
                
                if (preload.length > 0) {
                    score += 35;
                    details += `${preload.length} preload. `;
                }
                
                if (prefetch.length > 0) {
                    score += 15;
                    details += `${prefetch.length} prefetch. `;
                }
                
                return {
                    score: Math.min(score, 100),
                    details,
                    status: score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS_IMPROVEMENT'
                };
            }

            getScoreStatus(score) {
                if (score >= this.thresholds.excellent) return 'EXCELLENT';
                if (score >= this.thresholds.good) return 'GOOD';
                if (score >= this.thresholds.fair) return 'FAIR';
                return 'POOR';
            }

            updateProgress(categoryKey, categoryResults) {
                const resultsContainer = document.getElementById('results');
                const existingCard = document.getElementById(`card-${categoryKey}`);
                
                if (existingCard) {
                    existingCard.remove();
                }
                
                const card = document.createElement('div');
                card.className = 'benchmark-card';
                card.id = `card-${categoryKey}`;
                
                const statusClass = categoryResults.status.toLowerCase();
                const scoreClass = this.getScoreClass(categoryResults.score);
                
                card.innerHTML = `
                    <h3>${categoryResults.name}</h3>
                    <div class="benchmark-progress">
                        <div class="benchmark-progress-fill" style="width: ${categoryResults.score}%"></div>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Overall Score:</span>
                        <span class="metric-value ${scoreClass}">${categoryResults.score.toFixed(1)}%</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Status:</span>
                        <span class="metric-value ${scoreClass}">${categoryResults.status}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Tests Completed:</span>
                        <span class="metric-value">${Object.keys(categoryResults.tests).length}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Weight:</span>
                        <span class="metric-value">${(categoryResults.weight * 100).toFixed(0)}%</span>
                    </div>
                `;
                
                resultsContainer.appendChild(card);
            }

            getScoreClass(score) {
                if (score >= 90) return 'good';
                if (score >= 70) return 'warning';
                return 'poor';
            }

            calculateOverallScore() {
                if (Object.keys(this.results).length === 0) return;
                
                let weightedSum = 0;
                let totalWeight = 0;
                
                for (const category of Object.values(this.results)) {
                    weightedSum += category.score * category.weight;
                    totalWeight += category.weight;
                }
                
                this.overallScore = weightedSum / totalWeight;
                this.overallStatus = this.getScoreStatus(this.overallScore);
            }

            displayResults() {
                const summaryContainer = document.getElementById('summary');
                summaryContainer.style.display = 'block';
                
                const scoreClass = this.getScoreClass(this.overallScore).replace('warning', 'fair');
                
                summaryContainer.innerHTML = `
                    <h2>Overall Performance Score</h2>
                    <div class="overall-score ${scoreClass}">${this.overallScore.toFixed(1)}%</div>
                    <p>Status: <strong>${this.overallStatus}</strong></p>
                    <p>Based on weighted analysis of ${Object.keys(this.results).length} performance categories</p>
                `;
            }

            generateRecommendations() {
                const recommendations = [];
                
                for (const [key, category] of Object.entries(this.results)) {
                    if (category.score < 80) {
                        switch (key) {
                            case 'coreVitals':
                                if (category.score < 60) {
                                    recommendations.push('Implement Core Web Vitals optimization with lazy loading and resource preloading');
                                    recommendations.push('Add image dimensions to prevent layout shifts');
                                    recommendations.push('Optimize critical rendering path with inline CSS');
                                }
                                break;
                            case 'mobile':
                                if (category.score < 60) {
                                    recommendations.push('Improve touch response time and gesture recognition');
                                    recommendations.push('Optimize viewport configuration and orientation handling');
                                    recommendations.push('Implement mobile-specific optimizations and touch feedback');
                                }
                                break;
                            case 'pwa':
                                if (category.score < 60) {
                                    recommendations.push('Implement Service Worker for offline capabilities');
                                    recommendations.push('Add Web App Manifest for installability');
                                    recommendations.push('Optimize cache strategies for better performance');
                                }
                                break;
                            case 'errorHandling':
                                if (category.score < 60) {
                                    recommendations.push('Implement comprehensive error handling and recovery mechanisms');
                                    recommendations.push('Add fallback strategies for critical resources');
                                    recommendations.push('Optimize error detection and reporting overhead');
                                }
                                break;
                            case 'assetOptimization':
                                if (category.score < 60) {
                                    recommendations.push('Implement image lazy loading and responsive images');
                                    recommendations.push('Add resource hints (preload, preconnect, dns-prefetch)');
                                    recommendations.push('Optimize CSS and JavaScript loading strategies');
                                }
                                break;
                        }
                    }
                }
                
                if (recommendations.length === 0) {
                    recommendations.push('All performance categories are well optimized!');
                    recommendations.push('Continue monitoring performance metrics regularly');
                    recommendations.push('Consider A/B testing for further optimizations');
                }
                
                const recommendationsContainer = document.getElementById('recommendations');
                recommendationsContainer.style.display = 'block';
                recommendationsContainer.innerHTML = `
                    <h3>Performance Recommendations</h3>
                    ${recommendations.map(rec => `<div class="recommendation">${rec}</div>`).join('')}
                `;
            }

            async wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // Individual benchmark runners
            async runCoreVitalsBenchmark() {
                await this.runBenchmarkCategory('coreVitals', this.benchmarks.coreVitals);
                this.calculateOverallScore();
                this.displayResults();
            }

            async runMobileBenchmark() {
                await this.runBenchmarkCategory('mobile', this.benchmarks.mobile);
                this.calculateOverallScore();
                this.displayResults();
            }

            async runPWABenchmark() {
                await this.runBenchmarkCategory('pwa', this.benchmarks.pwa);
                this.calculateOverallScore();
                this.displayResults();
            }

            async runErrorHandlingBenchmark() {
                await this.runBenchmarkCategory('errorHandling', this.benchmarks.errorHandling);
                this.calculateOverallScore();
                this.displayResults();
            }

            async runAssetOptimizationBenchmark() {
                await this.runBenchmarkCategory('assetOptimization', this.benchmarks.assetOptimization);
                this.calculateOverallScore();
                this.displayResults();
            }

            clearResults() {
                this.results = {};
                this.logs = [];
                document.getElementById('results').innerHTML = '';
                document.getElementById('summary').style.display = 'none';
                document.getElementById('recommendations').style.display = 'none';
                document.getElementById('logs').innerHTML = '';
                this.updateStatus('Results cleared - ready for new benchmarks');
            }
        }

        // Initialize benchmark suite
        const benchmarkSuite = new PerformanceBenchmarkSuite();

        // Global functions for button handlers
        function runAllBenchmarks() {
            benchmarkSuite.runAllBenchmarks();
        }

        function runCoreVitalsBenchmark() {
            benchmarkSuite.runCoreVitalsBenchmark();
        }

        function runMobileBenchmark() {
            benchmarkSuite.runMobileBenchmark();
        }

        function runPWABenchmark() {
            benchmarkSuite.runPWABenchmark();
        }

        function runErrorHandlingBenchmark() {
            benchmarkSuite.runErrorHandlingBenchmark();
        }

        function runAssetOptimizationBenchmark() {
            benchmarkSuite.runAssetOptimizationBenchmark();
        }

        function clearResults() {
            benchmarkSuite.clearResults();
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            benchmarkSuite.log('Performance Benchmark Suite initialized and ready', 'success');
        });
    </script>
</body>
</html>