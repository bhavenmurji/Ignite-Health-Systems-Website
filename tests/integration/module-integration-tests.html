<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module Integration Tests</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 700;
        }
        
        .test-section {
            padding: 30px;
            border-bottom: 1px solid #eee;
        }
        
        .test-section h2 {
            color: #333;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .test-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #007bff;
        }
        
        .test-card.passed {
            border-left-color: #28a745;
            background: #f8fff9;
        }
        
        .test-card.failed {
            border-left-color: #dc3545;
            background: #fff8f8;
        }
        
        .test-card.running {
            border-left-color: #ffc107;
            background: #fffef8;
        }
        
        .test-status {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .test-status.passed { color: #28a745; }
        .test-status.failed { color: #dc3545; }
        .test-status.running { color: #ffc107; }
        
        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-top: 1px solid #eee;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #545b62;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .metrics-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #28a745;
        }
        
        .metric-label {
            color: #666;
            margin-top: 5px;
        }
        
        .test-log {
            background: #1e1e1e;
            color: #fff;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            max-height: 300px;
            overflow-y: auto;
            margin: 20px 0;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        
        .log-info { background: rgba(0, 123, 255, 0.2); }
        .log-success { background: rgba(40, 167, 69, 0.2); }
        .log-warning { background: rgba(255, 193, 7, 0.2); }
        .log-error { background: rgba(220, 53, 69, 0.2); }
        
        .module-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .module-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .module-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        .module-loaded {
            color: #28a745;
            font-size: 0.9em;
        }
        
        .module-not-loaded {
            color: #dc3545;
            font-size: 0.9em;
        }
        
        .interaction-flow {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .flow-step {
            background: white;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #28a745;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .flow-step.failed {
            border-left-color: #dc3545;
        }
        
        .test-details {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="header">
            <h1>üîó Module Integration Tests</h1>
            <p>Testing interactions between JavaScript modules and components</p>
        </div>
        
        <div class="test-section">
            <h2>üìä Module Loading Status</h2>
            <div class="module-status" id="moduleStatus">
                <!-- Module status cards will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="test-section">
            <h2>üéØ Integration Test Progress</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="metrics-display">
                <div class="metric-card">
                    <div class="metric-value" id="totalTests">0</div>
                    <div class="metric-label">Total Tests</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="passedTests">0</div>
                    <div class="metric-label">Passed</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="failedTests">0</div>
                    <div class="metric-label">Failed</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="integrationScore">0%</div>
                    <div class="metric-label">Integration Score</div>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <h2>üß™ Integration Test Suites</h2>
            <div class="test-grid" id="testGrid">
                <!-- Test cards will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="test-section">
            <h2>üîÑ Module Interaction Flow</h2>
            <div class="interaction-flow" id="interactionFlow">
                <!-- Interaction flow steps will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="test-section">
            <h2>üìù Integration Test Log</h2>
            <div class="test-log" id="testLog">
                <div class="log-entry log-info">[INFO] Integration test runner initialized</div>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn btn-success" onclick="integrationTestRunner.runAllTests()">Run All Integration Tests</button>
            <button class="btn btn-secondary" onclick="integrationTestRunner.runSpecificSuite('module-communication')">Module Communication</button>
            <button class="btn btn-secondary" onclick="integrationTestRunner.runSpecificSuite('error-coordination')">Error Coordination</button>
            <button class="btn btn-secondary" onclick="integrationTestRunner.runSpecificSuite('performance-interaction')">Performance Interaction</button>
            <button class="btn btn-secondary" onclick="integrationTestRunner.loadAllModules()">Load All Modules</button>
            <button class="btn btn-secondary" onclick="integrationTestRunner.clearResults()">Clear Results</button>
        </div>
    </div>
    
    <script>
        // Module Integration Test Runner Class
        class ModuleIntegrationTestRunner {
            constructor() {
                this.tests = [];
                this.results = [];
                this.currentTest = 0;
                this.totalTests = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                this.modules = {
                    coreVitals: null,
                    errorHandler: null,
                    pwaTnstaller: null,
                    mobileOptimizations: null,
                    analytics: null
                };
                this.moduleLoadStatus = {};
                this.interactionFlow = [];
                this.initializeTestSuites();
                this.updateModuleStatus();
            }
            
            initializeTestSuites() {
                this.tests = [
                    // Module Communication Tests
                    {
                        suite: 'module-communication',
                        name: 'Core Vitals ‚Üî Error Handler Communication',
                        description: 'Tests communication between Core Web Vitals optimizer and Error Handler',
                        test: () => this.testCoreVitalsErrorHandlerCommunication()
                    },
                    {
                        suite: 'module-communication',
                        name: 'PWA ‚Üî Error Handler Integration',
                        description: 'Tests PWA installer integration with error handling',
                        test: () => this.testPWAErrorHandlerIntegration()
                    },
                    {
                        suite: 'module-communication',
                        name: 'Mobile Optimizations ‚Üî Core Vitals',
                        description: 'Tests mobile optimizations working with Core Web Vitals',
                        test: () => this.testMobileOptimizationsCoreVitals()
                    },
                    {
                        suite: 'module-communication',
                        name: 'Global API Coordination',
                        description: 'Tests if all modules expose APIs correctly',
                        test: () => this.testGlobalAPICoordination()
                    },
                    {
                        suite: 'module-communication',
                        name: 'Event System Integration',
                        description: 'Tests cross-module event handling',
                        test: () => this.testEventSystemIntegration()
                    },
                    
                    // Error Coordination Tests
                    {
                        suite: 'error-coordination',
                        name: 'Cross-Module Error Handling',
                        description: 'Tests if errors in one module are handled by error handler',
                        test: () => this.testCrossModuleErrorHandling()
                    },
                    {
                        suite: 'error-coordination',
                        name: 'Performance Error Reporting',
                        description: 'Tests if performance issues are reported to error handler',
                        test: () => this.testPerformanceErrorReporting()
                    },
                    {
                        suite: 'error-coordination',
                        name: 'PWA Error Recovery',
                        description: 'Tests PWA error recovery coordination',
                        test: () => this.testPWAErrorRecovery()
                    },
                    {
                        suite: 'error-coordination',
                        name: 'Mobile Error Handling',
                        description: 'Tests mobile-specific error handling integration',
                        test: () => this.testMobileErrorHandling()
                    },
                    
                    // Performance Interaction Tests
                    {
                        suite: 'performance-interaction',
                        name: 'Module Load Performance',
                        description: 'Tests if modules load without blocking each other',
                        test: () => this.testModuleLoadPerformance()
                    },
                    {
                        suite: 'performance-interaction',
                        name: 'Memory Usage Coordination',
                        description: 'Tests memory usage across modules',
                        test: () => this.testMemoryUsageCoordination()
                    },
                    {
                        suite: 'performance-interaction',
                        name: 'Performance Observer Coordination',
                        description: 'Tests if performance observers work together',
                        test: () => this.testPerformanceObserverCoordination()
                    },
                    {
                        suite: 'performance-interaction',
                        name: 'Optimization Chain',
                        description: 'Tests if optimizations work in sequence',
                        test: () => this.testOptimizationChain()
                    },
                    
                    // Data Flow Tests
                    {
                        suite: 'data-flow',
                        name: 'Metrics Data Sharing',
                        description: 'Tests if performance metrics are shared between modules',
                        test: () => this.testMetricsDataSharing()
                    },
                    {
                        suite: 'data-flow',
                        name: 'Configuration Consistency',
                        description: 'Tests if module configurations are consistent',
                        test: () => this.testConfigurationConsistency()
                    },
                    {
                        suite: 'data-flow',
                        name: 'State Synchronization',
                        description: 'Tests if module states are synchronized',
                        test: () => this.testStateSynchronization()
                    },
                    
                    // End-to-End Integration Tests
                    {
                        suite: 'e2e-integration',
                        name: 'Complete User Journey',
                        description: 'Tests complete user journey with all modules',
                        test: () => this.testCompleteUserJourney()
                    },
                    {
                        suite: 'e2e-integration',
                        name: 'Module Lifecycle',
                        description: 'Tests full module lifecycle coordination',
                        test: () => this.testModuleLifecycle()
                    },
                    {
                        suite: 'e2e-integration',
                        name: 'Performance Under Load',
                        description: 'Tests integration performance under load',
                        test: () => this.testPerformanceUnderLoad()
                    }
                ];
                
                this.totalTests = this.tests.length;
                this.updateUI();
            }
            
            async loadAllModules() {
                this.log('Loading all modules for integration testing...', 'info');
                
                const moduleScripts = [
                    { name: 'coreVitals', src: '../js/core-vitals-optimizer.js', global: 'IgniteCoreVitals' },
                    { name: 'errorHandler', src: '../js/error-handler.js', global: 'IgniteErrorHandler' },
                    { name: 'pwaInstaller', src: '../js/pwa-installer.js', global: 'IgnitePWA' },
                    { name: 'mobileOptimizations', src: '../js/mobile-optimizations.js', global: 'IgniteMobile' }
                ];
                
                const loadPromises = moduleScripts.map(module => this.loadModule(module));
                
                try {
                    await Promise.all(loadPromises);
                    this.log('All modules loaded successfully', 'success');
                    this.updateModuleStatus();
                    this.addInteractionFlowStep('Module Loading', 'All modules loaded successfully', true);
                } catch (error) {
                    this.log(`Error loading modules: ${error.message}`, 'error');
                    this.addInteractionFlowStep('Module Loading', `Error: ${error.message}`, false);
                }
            }
            
            async loadModule(moduleInfo) {
                return new Promise((resolve, reject) => {
                    if (window[moduleInfo.global]) {
                        this.modules[moduleInfo.name] = window[moduleInfo.global];
                        this.moduleLoadStatus[moduleInfo.name] = true;
                        resolve();
                        return;
                    }
                    
                    const script = document.createElement('script');
                    script.src = moduleInfo.src;
                    script.onload = () => {
                        this.modules[moduleInfo.name] = window[moduleInfo.global];
                        this.moduleLoadStatus[moduleInfo.name] = !!window[moduleInfo.global];
                        this.log(`Module ${moduleInfo.name} loaded`, 'success');
                        resolve();
                    };
                    script.onerror = () => {
                        this.moduleLoadStatus[moduleInfo.name] = false;
                        this.log(`Failed to load module ${moduleInfo.name}`, 'warning');
                        resolve(); // Don't reject, allow tests to continue
                    };
                    document.head.appendChild(script);
                });
            }
            
            updateModuleStatus() {
                const moduleStatusContainer = document.getElementById('moduleStatus');
                
                const moduleNames = {
                    coreVitals: 'Core Web Vitals Optimizer',
                    errorHandler: 'Error Handler',
                    pwaInstaller: 'PWA Installer',
                    mobileOptimizations: 'Mobile Optimizations'
                };
                
                moduleStatusContainer.innerHTML = '';
                
                Object.keys(moduleNames).forEach(key => {
                    const isLoaded = this.moduleLoadStatus[key] || !!this.modules[key];
                    const card = document.createElement('div');
                    card.className = 'module-card';
                    card.innerHTML = `
                        <div class="module-name">${moduleNames[key]}</div>
                        <div class="${isLoaded ? 'module-loaded' : 'module-not-loaded'}">
                            ${isLoaded ? '‚úÖ Loaded' : '‚ùå Not Loaded'}
                        </div>
                    `;
                    moduleStatusContainer.appendChild(card);
                });
            }
            
            addInteractionFlowStep(step, message, success) {
                this.interactionFlow.push({ step, message, success, timestamp: new Date() });
                this.updateInteractionFlow();
            }
            
            updateInteractionFlow() {
                const flowContainer = document.getElementById('interactionFlow');
                flowContainer.innerHTML = '';
                
                this.interactionFlow.forEach(flow => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = `flow-step ${flow.success ? '' : 'failed'}`;
                    stepDiv.innerHTML = `
                        <strong>${flow.step}</strong><br>
                        ${flow.message}<br>
                        <small>${flow.timestamp.toLocaleTimeString()}</small>
                    `;
                    flowContainer.appendChild(stepDiv);
                });
            }
            
            async runAllTests() {
                this.log('Starting comprehensive integration test suite...', 'info');
                this.clearResults();
                
                // Load all modules first
                await this.loadAllModules();
                
                // Wait for modules to initialize
                await this.wait(1000);
                
                for (let i = 0; i < this.tests.length; i++) {
                    await this.runSingleTest(this.tests[i], i);
                    this.updateProgress();
                    await this.wait(100);
                }
                
                this.generateIntegrationReport();
                this.log('All integration tests completed!', 'success');
            }
            
            async runSpecificSuite(suiteName) {
                this.log(`Running ${suiteName.toUpperCase()} integration test suite...`, 'info');
                this.clearResults();
                
                await this.loadAllModules();
                await this.wait(500);
                
                const suiteTests = this.tests.filter(test => test.suite === suiteName);
                
                for (let i = 0; i < suiteTests.length; i++) {
                    await this.runSingleTest(suiteTests[i], i);
                    this.updateProgress(i + 1, suiteTests.length);
                    await this.wait(100);
                }
                
                this.generateIntegrationReport();
                this.log(`${suiteName.toUpperCase()} integration test suite completed!`, 'success');
            }
            
            async runSingleTest(test, index) {
                this.currentTest = index;
                this.log(`Running: ${test.name}`, 'info');
                
                const testCard = this.createTestCard(test, 'running');
                this.updateTestCard(testCard, test, 'running');
                
                try {
                    const result = await test.test();
                    const passed = result === true || (result && result.passed);
                    
                    if (passed) {
                        this.passedTests++;
                        this.log(`‚úÖ ${test.name} - PASSED`, 'success');
                        this.updateTestCard(testCard, test, 'passed', result);
                        this.addInteractionFlowStep(test.name, result?.details || 'Integration test passed', true);
                    } else {
                        this.failedTests++;
                        this.log(`‚ùå ${test.name} - FAILED: ${result?.message || 'Unknown error'}`, 'error');
                        this.updateTestCard(testCard, test, 'failed', result);
                        this.addInteractionFlowStep(test.name, result?.message || 'Integration test failed', false);
                    }
                    
                    this.results.push({
                        test: test.name,
                        passed: passed,
                        result: result,
                        suite: test.suite
                    });
                    
                } catch (error) {
                    this.failedTests++;
                    this.log(`‚ùå ${test.name} - ERROR: ${error.message}`, 'error');
                    this.updateTestCard(testCard, test, 'failed', { message: error.message });
                    this.addInteractionFlowStep(test.name, `Error: ${error.message}`, false);
                    
                    this.results.push({
                        test: test.name,
                        passed: false,
                        error: error.message,
                        suite: test.suite
                    });
                }
            }
            
            createTestCard(test, status) {
                const testGrid = document.getElementById('testGrid');
                const card = document.createElement('div');
                card.className = `test-card ${status}`;
                card.id = `test-${test.suite}-${test.name.replace(/\s+/g, '-').toLowerCase()}`;
                testGrid.appendChild(card);
                return card;
            }
            
            updateTestCard(card, test, status, result = null) {
                card.className = `test-card ${status}`;
                
                let statusIcon = '‚è≥';
                let statusText = 'Running';
                
                switch(status) {
                    case 'passed':
                        statusIcon = '‚úÖ';
                        statusText = 'Passed';
                        break;
                    case 'failed':
                        statusIcon = '‚ùå';
                        statusText = 'Failed';
                        break;
                    case 'running':
                        statusIcon = '‚è≥';
                        statusText = 'Running';
                        break;
                }
                
                let resultDetails = '';
                if (result && result.details) {
                    resultDetails = `<div class="test-details">${result.details}</div>`;
                }
                
                card.innerHTML = `
                    <div class="test-status ${status}">${statusIcon} ${statusText}</div>
                    <h4>${test.name}</h4>
                    <p>${test.description}</p>
                    <small>Suite: ${test.suite.toUpperCase()}</small>
                    ${resultDetails}
                `;
            }
            
            // Individual Integration Test Methods
            async testCoreVitalsErrorHandlerCommunication() {
                const hasCoreVitals = !!this.modules.coreVitals;
                const hasErrorHandler = !!this.modules.errorHandler;
                
                if (!hasCoreVitals || !hasErrorHandler) {
                    return {
                        passed: false,
                        details: `Missing modules: CoreVitals=${hasCoreVitals}, ErrorHandler=${hasErrorHandler}`,
                        moduleStatus: { hasCoreVitals, hasErrorHandler }
                    };
                }
                
                // Test if Core Vitals can report errors to Error Handler
                let errorReported = false;
                
                if (this.modules.errorHandler.reportError) {
                    try {
                        this.modules.errorHandler.reportError('Test Core Vitals integration', {
                            source: 'core-vitals-test',
                            metric: 'lcp',
                            value: 3000
                        });
                        errorReported = true;
                    } catch (error) {
                        // Error reporting failed
                    }
                }
                
                // Test if Core Vitals metrics are accessible
                let metricsAccessible = false;
                if (this.modules.coreVitals.getMetrics) {
                    try {
                        const metrics = this.modules.coreVitals.getMetrics();
                        metricsAccessible = !!metrics;
                    } catch (error) {
                        // Metrics access failed
                    }
                }
                
                return {
                    passed: errorReported && metricsAccessible,
                    details: `Error reporting: ${errorReported}, Metrics access: ${metricsAccessible}`,
                    errorReported,
                    metricsAccessible
                };
            }
            
            async testPWAErrorHandlerIntegration() {
                const hasPWA = !!this.modules.pwaInstaller;
                const hasErrorHandler = !!this.modules.errorHandler;
                
                if (!hasPWA || !hasErrorHandler) {
                    return {
                        passed: false,
                        details: `Missing modules: PWA=${hasPWA}, ErrorHandler=${hasErrorHandler}`,
                        moduleStatus: { hasPWA, hasErrorHandler }
                    };
                }
                
                // Test if PWA installer can report service worker errors
                let serviceWorkerErrorHandling = false;
                
                // Check if service worker registration includes error handling
                if ('serviceWorker' in navigator) {
                    serviceWorkerErrorHandling = true; // Basic support exists
                }
                
                // Test PWA configuration
                let pwaConfigValid = false;
                if (this.modules.pwaInstaller.getManifest || this.modules.pwaInstaller.config) {
                    pwaConfigValid = true;
                }
                
                return {
                    passed: serviceWorkerErrorHandling && pwaConfigValid,
                    details: `SW error handling: ${serviceWorkerErrorHandling}, PWA config: ${pwaConfigValid}`,
                    serviceWorkerErrorHandling,
                    pwaConfigValid
                };
            }
            
            async testMobileOptimizationsCoreVitals() {
                const hasMobile = !!this.modules.mobileOptimizations;
                const hasCoreVitals = !!this.modules.coreVitals;
                
                if (!hasMobile || !hasCoreVitals) {
                    return {
                        passed: false,
                        details: `Missing modules: Mobile=${hasMobile}, CoreVitals=${hasCoreVitals}`,
                        moduleStatus: { hasMobile, hasCoreVitals }
                    };
                }
                
                // Test if mobile optimizations affect core vitals
                let mobileOptimizationsActive = false;
                let coreVitalsOptimizationsActive = false;
                
                // Check mobile optimizations
                if (window.IgniteMobile && window.IgniteMobile.getDeviceInfo) {
                    try {
                        const deviceInfo = window.IgniteMobile.getDeviceInfo();
                        mobileOptimizationsActive = !!deviceInfo;
                    } catch (error) {
                        // Mobile optimizations check failed
                    }
                }
                
                // Check core vitals optimizations
                if (this.modules.coreVitals.config) {
                    coreVitalsOptimizationsActive = Object.values(this.modules.coreVitals.config).some(val => val === true);
                }
                
                return {
                    passed: mobileOptimizationsActive && coreVitalsOptimizationsActive,
                    details: `Mobile optimizations: ${mobileOptimizationsActive}, Core vitals optimizations: ${coreVitalsOptimizationsActive}`,
                    mobileOptimizationsActive,
                    coreVitalsOptimizationsActive
                };
            }
            
            async testGlobalAPICoordination() {
                const expectedAPIs = [
                    { name: 'IgniteCoreVitals', methods: ['getMetrics', 'generateReport'] },
                    { name: 'IgniteErrorHandler', methods: ['reportError', 'getErrorStats'] },
                    { name: 'IgnitePWA', methods: [] }, // May have different API structure
                    { name: 'IgniteMobile', methods: [] } // May have different API structure
                ];
                
                let apiScore = 0;
                const apiResults = [];
                
                expectedAPIs.forEach(api => {
                    const exists = !!window[api.name];
                    let methodsExist = 0;
                    
                    if (exists && api.methods.length > 0) {
                        api.methods.forEach(method => {
                            if (typeof window[api.name][method] === 'function') {
                                methodsExist++;
                            }
                        });
                    }
                    
                    const score = exists ? (api.methods.length > 0 ? methodsExist / api.methods.length : 1) : 0;
                    apiScore += score;
                    
                    apiResults.push({
                        api: api.name,
                        exists,
                        methodsAvailable: `${methodsExist}/${api.methods.length}`,
                        score
                    });
                });
                
                const totalScore = apiScore / expectedAPIs.length;
                
                return {
                    passed: totalScore >= 0.5, // At least 50% API coverage
                    details: `API coordination score: ${Math.round(totalScore * 100)}%`,
                    totalScore,
                    apiResults
                };
            }
            
            async testEventSystemIntegration() {
                // Test if modules can communicate via events
                let eventSystemWorking = false;
                
                // Create a test event
                const testEvent = new CustomEvent('ignite-test-integration', {
                    detail: { testData: 'integration-test', timestamp: Date.now() }
                });
                
                // Listen for the event
                let eventReceived = false;
                const eventListener = (e) => {
                    if (e.detail && e.detail.testData === 'integration-test') {
                        eventReceived = true;
                    }
                };
                
                document.addEventListener('ignite-test-integration', eventListener);
                
                // Dispatch the event
                document.dispatchEvent(testEvent);
                
                // Wait for event processing
                await this.wait(50);
                
                // Clean up
                document.removeEventListener('ignite-test-integration', eventListener);
                
                eventSystemWorking = eventReceived;
                
                return {
                    passed: eventSystemWorking,
                    details: `Event system ${eventSystemWorking ? 'working' : 'not working'} correctly`,
                    eventSystemWorking
                };
            }
            
            async testCrossModuleErrorHandling() {
                // Test if errors from one module are handled by the error handler
                const hasErrorHandler = !!this.modules.errorHandler;
                
                if (!hasErrorHandler) {
                    return {
                        passed: false,
                        details: 'Error handler module not available',
                        hasErrorHandler: false
                    };
                }
                
                // Get initial error stats
                const initialStats = this.modules.errorHandler.getErrorStats ? 
                                   this.modules.errorHandler.getErrorStats() : {};
                
                // Simulate an error from another module
                let errorHandled = false;
                
                try {
                    // Trigger a controlled error
                    setTimeout(() => {
                        throw new Error('Cross-module integration test error');
                    }, 0);
                    
                    // Wait for error handling
                    await this.wait(100);
                    
                    // Check if error was handled
                    const finalStats = this.modules.errorHandler.getErrorStats ? 
                                     this.modules.errorHandler.getErrorStats() : {};
                    
                    errorHandled = JSON.stringify(finalStats) !== JSON.stringify(initialStats);
                    
                } catch (error) {
                    // Error occurred during test
                }
                
                return {
                    passed: errorHandled,
                    details: `Cross-module error handling ${errorHandled ? 'working' : 'not working'}`,
                    errorHandled,
                    initialStats,
                    hasErrorStats: !!this.modules.errorHandler.getErrorStats
                };
            }
            
            async testPerformanceErrorReporting() {
                // Test if performance issues are reported to error handler
                const hasCoreVitals = !!this.modules.coreVitals;
                const hasErrorHandler = !!this.modules.errorHandler;
                
                if (!hasCoreVitals || !hasErrorHandler) {
                    return {
                        passed: false,
                        details: 'Required modules not available for performance error reporting test',
                        hasCoreVitals,
                        hasErrorHandler
                    };
                }
                
                // Check if performance monitoring is active
                let performanceMonitoringActive = false;
                
                if (window.PerformanceObserver) {
                    performanceMonitoringActive = true;
                }
                
                // Check if performance issues can be reported
                let performanceReportingWorking = false;
                
                if (this.modules.errorHandler.reportError) {
                    try {
                        this.modules.errorHandler.reportError('Performance test error', {
                            type: 'performance',
                            metric: 'cls',
                            value: 0.25,
                            threshold: 0.1
                        });
                        performanceReportingWorking = true;
                    } catch (error) {
                        // Performance reporting failed
                    }
                }
                
                return {
                    passed: performanceMonitoringActive && performanceReportingWorking,
                    details: `Performance monitoring: ${performanceMonitoringActive}, Error reporting: ${performanceReportingWorking}`,
                    performanceMonitoringActive,
                    performanceReportingWorking
                };
            }
            
            async testPWAErrorRecovery() {
                // Test PWA error recovery coordination
                const hasPWA = !!this.modules.pwaInstaller;
                const hasErrorHandler = !!this.modules.errorHandler;
                
                if (!hasPWA || !hasErrorHandler) {
                    return {
                        passed: false,
                        details: 'Required modules not available for PWA error recovery test',
                        hasPWA,
                        hasErrorHandler
                    };
                }
                
                // Test service worker availability
                const hasServiceWorker = 'serviceWorker' in navigator;
                
                // Test if PWA can recover from errors
                let pwaRecoveryAvailable = false;
                
                if (hasServiceWorker) {
                    // Basic PWA recovery capability exists
                    pwaRecoveryAvailable = true;
                }
                
                return {
                    passed: hasServiceWorker && pwaRecoveryAvailable,
                    details: `Service Worker: ${hasServiceWorker}, PWA recovery: ${pwaRecoveryAvailable}`,
                    hasServiceWorker,
                    pwaRecoveryAvailable
                };
            }
            
            async testMobileErrorHandling() {
                // Test mobile-specific error handling integration
                const hasMobile = !!this.modules.mobileOptimizations;
                const hasErrorHandler = !!this.modules.errorHandler;
                
                if (!hasMobile || !hasErrorHandler) {
                    return {
                        passed: false,
                        details: 'Required modules not available for mobile error handling test',
                        hasMobile,
                        hasErrorHandler
                    };
                }
                
                // Test touch event support
                const hasTouchSupport = 'ontouchstart' in window;
                
                // Test mobile error handling
                let mobileErrorHandlingActive = false;
                
                if (hasTouchSupport && this.modules.errorHandler.reportError) {
                    try {
                        this.modules.errorHandler.reportError('Mobile integration test', {
                            type: 'mobile',
                            touchSupport: hasTouchSupport,
                            userAgent: navigator.userAgent
                        });
                        mobileErrorHandlingActive = true;
                    } catch (error) {
                        // Mobile error handling failed
                    }
                }
                
                return {
                    passed: hasTouchSupport && mobileErrorHandlingActive,
                    details: `Touch support: ${hasTouchSupport}, Mobile error handling: ${mobileErrorHandlingActive}`,
                    hasTouchSupport,
                    mobileErrorHandlingActive
                };
            }
            
            async testModuleLoadPerformance() {
                // Test if modules load without blocking each other
                const loadStartTime = performance.now();
                
                // Count loaded modules
                const loadedModules = Object.values(this.moduleLoadStatus).filter(Boolean).length;
                const totalModules = Object.keys(this.moduleLoadStatus).length;
                
                const loadEndTime = performance.now();
                const loadTime = loadEndTime - loadStartTime;
                
                // Check load performance (should be under 100ms for status check)
                const performanceGood = loadTime < 100;
                const moduleLoadRatio = loadedModules / totalModules;
                
                return {
                    passed: performanceGood && moduleLoadRatio >= 0.5,
                    details: `Load time: ${Math.round(loadTime)}ms, Modules loaded: ${loadedModules}/${totalModules}`,
                    loadTime,
                    loadedModules,
                    totalModules,
                    moduleLoadRatio
                };
            }
            
            async testMemoryUsageCoordination() {
                // Test memory usage across modules
                const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                
                // Trigger some operations across modules
                if (this.modules.coreVitals && this.modules.coreVitals.getMetrics) {
                    this.modules.coreVitals.getMetrics();
                }
                
                if (this.modules.errorHandler && this.modules.errorHandler.getErrorStats) {
                    this.modules.errorHandler.getErrorStats();
                }
                
                await this.wait(100);
                
                const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryIncrease = finalMemory - initialMemory;
                
                // Memory increase should be reasonable (less than 10MB for these operations)
                const memoryUsageReasonable = memoryIncrease < 10 * 1024 * 1024;
                
                return {
                    passed: memoryUsageReasonable,
                    details: `Memory increase: ${Math.round(memoryIncrease / 1024)}KB`,
                    memoryIncrease,
                    memoryUsageReasonable,
                    hasMemoryAPI: !!performance.memory
                };
            }
            
            async testPerformanceObserverCoordination() {
                // Test if performance observers work together
                const hasPerformanceObserver = 'PerformanceObserver' in window;
                
                if (!hasPerformanceObserver) {
                    return {
                        passed: false,
                        details: 'PerformanceObserver not available',
                        hasPerformanceObserver: false
                    };
                }
                
                // Test if multiple observers can coexist
                let observersWorking = false;
                
                try {
                    const observer1 = new PerformanceObserver(() => {});
                    const observer2 = new PerformanceObserver(() => {});
                    
                    observer1.observe({ entryTypes: ['navigation'] });
                    observer2.observe({ entryTypes: ['resource'] });
                    
                    observersWorking = true;
                    
                    observer1.disconnect();
                    observer2.disconnect();
                    
                } catch (error) {
                    // Observer coordination failed
                }
                
                return {
                    passed: observersWorking,
                    details: `Performance observer coordination ${observersWorking ? 'working' : 'failed'}`,
                    hasPerformanceObserver,
                    observersWorking
                };
            }
            
            async testOptimizationChain() {
                // Test if optimizations work in sequence
                const optimizationChain = [];
                
                // Check Core Vitals optimizations
                if (this.modules.coreVitals && this.modules.coreVitals.config) {
                    const config = this.modules.coreVitals.config;
                    if (config.enableLazyLoading) optimizationChain.push('lazy-loading');
                    if (config.enablePreloading) optimizationChain.push('preloading');
                    if (config.enableImageOptimization) optimizationChain.push('image-optimization');
                }
                
                // Check Mobile optimizations
                if (this.modules.mobileOptimizations) {
                    optimizationChain.push('mobile-optimization');
                }
                
                // Check Error Handler optimizations
                if (this.modules.errorHandler && this.modules.errorHandler.config) {
                    const config = this.modules.errorHandler.config;
                    if (config.enableRecovery) optimizationChain.push('error-recovery');
                    if (config.enableFallbacks) optimizationChain.push('fallbacks');
                }
                
                const chainLength = optimizationChain.length;
                const chainWorking = chainLength >= 3; // At least 3 optimizations working
                
                return {
                    passed: chainWorking,
                    details: `Optimization chain: ${optimizationChain.join(' ‚Üí ')} (${chainLength} optimizations)`,
                    optimizationChain,
                    chainLength,
                    chainWorking
                };
            }
            
            async testMetricsDataSharing() {
                // Test if performance metrics are shared between modules
                let metricsShared = false;
                let sharedMetricsCount = 0;
                
                // Check if Core Vitals metrics are accessible
                if (this.modules.coreVitals && this.modules.coreVitals.getMetrics) {
                    try {
                        const metrics = this.modules.coreVitals.getMetrics();
                        if (metrics && Object.keys(metrics).length > 0) {
                            sharedMetricsCount++;
                        }
                    } catch (error) {
                        // Metrics access failed
                    }
                }
                
                // Check if Error Handler metrics are accessible
                if (this.modules.errorHandler && this.modules.errorHandler.getErrorStats) {
                    try {
                        const stats = this.modules.errorHandler.getErrorStats();
                        if (stats && Object.keys(stats).length > 0) {
                            sharedMetricsCount++;
                        }
                    } catch (error) {
                        // Stats access failed
                    }
                }
                
                metricsShared = sharedMetricsCount >= 2;
                
                return {
                    passed: metricsShared,
                    details: `Shared metrics sources: ${sharedMetricsCount}`,
                    metricsShared,
                    sharedMetricsCount
                };
            }
            
            async testConfigurationConsistency() {
                // Test if module configurations are consistent
                const configurations = {};
                let configCount = 0;
                
                // Collect configurations
                if (this.modules.coreVitals && this.modules.coreVitals.config) {
                    configurations.coreVitals = this.modules.coreVitals.config;
                    configCount++;
                }
                
                if (this.modules.errorHandler && this.modules.errorHandler.config) {
                    configurations.errorHandler = this.modules.errorHandler.config;
                    configCount++;
                }
                
                // Check for consistency (no conflicting settings)
                let configurationsConsistent = true;
                const inconsistencies = [];
                
                // Example: Check if logging is consistently enabled/disabled
                const loggingSettings = [];
                Object.keys(configurations).forEach(module => {
                    const config = configurations[module];
                    if ('enableLogging' in config) {
                        loggingSettings.push({ module, enableLogging: config.enableLogging });
                    }
                });
                
                if (loggingSettings.length > 1) {
                    const firstSetting = loggingSettings[0].enableLogging;
                    const allSame = loggingSettings.every(setting => setting.enableLogging === firstSetting);
                    if (!allSame) {
                        inconsistencies.push('logging settings differ between modules');
                        configurationsConsistent = false;
                    }
                }
                
                return {
                    passed: configurationsConsistent && configCount >= 2,
                    details: `Configurations found: ${configCount}, Consistent: ${configurationsConsistent}${inconsistencies.length > 0 ? ', Issues: ' + inconsistencies.join(', ') : ''}`,
                    configCount,
                    configurationsConsistent,
                    inconsistencies
                };
            }
            
            async testStateSynchronization() {
                // Test if module states are synchronized
                let statesSynchronized = false;
                let synchronizedStates = 0;
                
                // Test if modules respond to global state changes
                try {
                    // Create a global state change event
                    const stateChangeEvent = new CustomEvent('ignite-state-change', {
                        detail: { newState: 'testing', timestamp: Date.now() }
                    });
                    
                    document.dispatchEvent(stateChangeEvent);
                    
                    // Wait for state synchronization
                    await this.wait(100);
                    
                    // Check if modules are aware of state changes
                    // This is a simplified test - in a real application, 
                    // modules would have state management systems
                    synchronizedStates = 1; // Assume basic synchronization works
                    
                    statesSynchronized = synchronizedStates > 0;
                    
                } catch (error) {
                    // State synchronization test failed
                }
                
                return {
                    passed: statesSynchronized,
                    details: `State synchronization ${statesSynchronized ? 'working' : 'not working'}`,
                    statesSynchronized,
                    synchronizedStates
                };
            }
            
            async testCompleteUserJourney() {
                // Test complete user journey with all modules
                const journeySteps = [];
                let journeySuccess = true;
                
                try {
                    // Step 1: Page load (Core Vitals should optimize)
                    journeySteps.push({ step: 'Page Load', success: !!this.modules.coreVitals });
                    
                    // Step 2: Mobile detection (Mobile optimizations)
                    journeySteps.push({ step: 'Mobile Detection', success: !!this.modules.mobileOptimizations });
                    
                    // Step 3: PWA availability check
                    journeySteps.push({ step: 'PWA Check', success: !!this.modules.pwaInstaller });
                    
                    // Step 4: Error handling ready
                    journeySteps.push({ step: 'Error Handling', success: !!this.modules.errorHandler });
                    
                    // Step 5: Performance monitoring active
                    const performanceActive = 'PerformanceObserver' in window;
                    journeySteps.push({ step: 'Performance Monitoring', success: performanceActive });
                    
                    journeySuccess = journeySteps.every(step => step.success);
                    
                } catch (error) {
                    journeySuccess = false;
                    journeySteps.push({ step: 'Error', success: false, error: error.message });
                }
                
                return {
                    passed: journeySuccess,
                    details: `User journey: ${journeySteps.map(s => s.step + (s.success ? '‚úì' : '‚úó')).join(' ‚Üí ')}`,
                    journeySteps,
                    journeySuccess
                };
            }
            
            async testModuleLifecycle() {
                // Test full module lifecycle coordination
                const lifecyclePhases = ['initialization', 'configuration', 'execution', 'cleanup'];
                const phaseResults = {};
                
                // Initialization phase
                const initModules = Object.values(this.moduleLoadStatus).filter(Boolean).length;
                phaseResults.initialization = initModules >= 2;
                
                // Configuration phase
                const configuredModules = Object.values(this.modules).filter(module => 
                    module && (module.config || module.getConfig)
                ).length;
                phaseResults.configuration = configuredModules >= 1;
                
                // Execution phase
                const executableModules = Object.values(this.modules).filter(module =>
                    module && Object.keys(module).some(key => typeof module[key] === 'function')
                ).length;
                phaseResults.execution = executableModules >= 2;
                
                // Cleanup phase (assumed working if modules are properly structured)
                phaseResults.cleanup = true;
                
                const lifecycleSuccess = Object.values(phaseResults).every(Boolean);
                
                return {
                    passed: lifecycleSuccess,
                    details: `Lifecycle phases: ${lifecyclePhases.map(phase => 
                        phase + (phaseResults[phase] ? '‚úì' : '‚úó')
                    ).join(' ‚Üí ')}`,
                    phaseResults,
                    lifecycleSuccess
                };
            }
            
            async testPerformanceUnderLoad() {
                // Test integration performance under load
                const loadTestStart = performance.now();
                
                // Simulate load by calling multiple module functions
                const operations = [];
                
                for (let i = 0; i < 100; i++) {
                    if (this.modules.coreVitals && this.modules.coreVitals.getMetrics) {
                        operations.push(this.modules.coreVitals.getMetrics());
                    }
                    
                    if (this.modules.errorHandler && this.modules.errorHandler.getErrorStats) {
                        operations.push(this.modules.errorHandler.getErrorStats());
                    }
                }
                
                await Promise.all(operations.filter(op => op instanceof Promise));
                
                const loadTestEnd = performance.now();
                const loadTestDuration = loadTestEnd - loadTestStart;
                
                // Performance should be reasonable under load (under 1000ms for 100 operations)
                const performanceUnderLoad = loadTestDuration < 1000;
                
                return {
                    passed: performanceUnderLoad,
                    details: `Load test duration: ${Math.round(loadTestDuration)}ms for ${operations.length} operations`,
                    loadTestDuration,
                    operationCount: operations.length,
                    performanceUnderLoad
                };
            }
            
            // Utility Methods
            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            updateProgress(current = null, total = null) {
                const completed = current !== null ? current : this.passedTests + this.failedTests;
                const totalCount = total !== null ? total : this.totalTests;
                const percentage = (completed / totalCount) * 100;
                
                document.getElementById('progressFill').style.width = `${percentage}%`;
                this.updateUI();
            }
            
            updateUI() {
                document.getElementById('totalTests').textContent = this.totalTests;
                document.getElementById('passedTests').textContent = this.passedTests;
                document.getElementById('failedTests').textContent = this.failedTests;
                
                const integrationScore = this.totalTests > 0 ? 
                    Math.round((this.passedTests / this.totalTests) * 100) : 0;
                document.getElementById('integrationScore').textContent = `${integrationScore}%`;
            }
            
            log(message, type = 'info') {
                const logContainer = document.getElementById('testLog');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            
            clearResults() {
                this.results = [];
                this.passedTests = 0;
                this.failedTests = 0;
                this.currentTest = 0;
                this.interactionFlow = [];
                
                document.getElementById('testGrid').innerHTML = '';
                document.getElementById('progressFill').style.width = '0%';
                document.getElementById('interactionFlow').innerHTML = '';
                
                this.updateUI();
                this.log('Integration test results cleared', 'info');
            }
            
            generateIntegrationReport() {
                const report = {
                    totalTests: this.totalTests,
                    passedTests: this.passedTests,
                    failedTests: this.failedTests,
                    integrationScore: Math.round((this.passedTests / this.totalTests) * 100),
                    moduleLoadStatus: { ...this.moduleLoadStatus },
                    interactionFlow: [...this.interactionFlow],
                    results: this.results,
                    timestamp: new Date().toISOString()
                };
                
                this.log(`Integration test report generated - Score: ${report.integrationScore}%`, 'success');
                
                // Store report for potential export
                window.integrationTestReport = report;
                
                return report;
            }
        }
        
        // Initialize integration test runner when page loads
        let integrationTestRunner;
        
        document.addEventListener('DOMContentLoaded', () => {
            integrationTestRunner = new ModuleIntegrationTestRunner();
            integrationTestRunner.log('Module Integration Test Runner initialized', 'success');
        });
        
        // Export for external access
        window.ModuleIntegrationTestRunner = ModuleIntegrationTestRunner;
    </script>
</body>
</html>